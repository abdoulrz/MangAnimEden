{% extends "administration/base_admin.html" %}

{% block admin_content %}
<div class="admin-header">
    <h1 class="admin-page-title">
        {% if form.instance.pk %}Modifier {{ form.instance.title }}{% else %}Nouvelle Série{% endif %}
    </h1>
    <a href="{% url 'administration:series_list' %}" class="btn btn-secondary">Retour</a>
</div>

<style>
    .upload-progress-hidden {
        display: none;
        margin-top: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .upload-progress-bg {
        height: 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .upload-progress-fill {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #8B5CF6 0%, #EC4899 100%);
        transition: width 0.3s ease;
        box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
    }

    .upload-status-text {
        color: var(--color-text-secondary);
        margin-top: 8px;
        display: block;
        font-weight: 500;
    }
</style>

<div class="form-container">
    <form method="post" enctype="multipart/form-data" class="admin-form">
        {% csrf_token %}

        <div class="form-grid">
            <div class="form-group span-2">
                <label for="id_title">Titre</label>
                {{ form.title }}
                {% if form.title.errors %}<div class="error">{{ form.title.errors }}</div>{% endif %}
            </div>

            <div class="form-group span-2">
                <label for="id_slug">Slug (laisser vide pour auto-générer)</label>
                {{ form.slug }}
            </div>

            <div class="form-group span-2">
                <label for="id_description">Description</label>
                {{ form.description }}
            </div>

            <div class="form-group">
                <label for="id_cover">Couverture</label>
                {{ form.cover }}
            </div>

            <!-- Folder Upload (Progressive) -->
            <div class="form-group span-2">
                <label for="folder_upload">Importer un dossier de chapitres (Optionnel)</label>
                <input type="file" name="folder_upload" id="folder_upload" class="form-control" webkitdirectory
                    directory multiple>
                <div id="upload-progress-container" class="upload-progress-container upload-progress-hidden">
                    <div class="progress-bar-bg upload-progress-bg">
                        <div id="upload-progress-bar" class="progress-bar-fill upload-progress-fill">
                        </div>
                    </div>
                    <small id="upload-status-text" class="upload-status-text">Préparation...</small>
                </div>
            </div>

            <div class="form-group">
                <label for="id_type">Type</label>
                {{ form.type }}
            </div>

            <div class="form-group">
                <label for="id_author">Auteur</label>
                {{ form.author }}
            </div>

            <div class="form-group">
                <label for="id_artist">Artiste</label>
                {{ form.artist }}
            </div>

            <div class="form-group">
                <label for="id_status">Statut</label>
                {{ form.status }}
            </div>

            <div class="form-group">
                <label for="id_release_date">Date de Sortie</label>
                {{ form.release_date }}
            </div>

            <div class="form-group span-2">
                <label for="id_genres">Genres</label>
                <div class="genres-selection-container">
                    {{ form.genres }}
                </div>
            </div>
        </div>

        <div class="form-actions">
            <button type="submit" class="btn btn-primary">Enregistrer</button>
        </div>
    </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const form = document.querySelector('.admin-form');
        const folderInput = document.getElementById('folder_upload');
        const progressContainer = document.getElementById('upload-progress-container');
        const progressBar = document.getElementById('upload-progress-bar');
        const statusText = document.getElementById('upload-status-text');
        const submitBtn = form.querySelector('button[type="submit"]');

        if (!form || !folderInput) return;

        // Helper: fetch with detailed error info
        async function safeFetch(url, options, label) {
            const res = await fetch(url, options);
            if (!res.ok) {
                const body = await res.text();
                console.error(`[${label}] FAILED`, { url, status: res.status, body: body.substring(0, 500) });
                throw new Error(`[${label}] ${res.status} — ${body.substring(0, 150)}`);
            }
            return res;
        }

        let completedUploadIds = [];
        let isUploading = false;

        folderInput.addEventListener('change', async function (e) {
            const files = Array.from(folderInput.files);
            if (files.length === 0) return;

            // Optional: reset if they select a new folder
            completedUploadIds = [];
            isUploading = true;
            submitBtn.disabled = true;
            progressContainer.style.display = 'block';

            try {
                // Background UPLOAD Phase
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const overallPercent = Math.round((i / files.length) * 100);
                    progressBar.style.width = `${overallPercent}%`;
                    statusText.innerText = `[${i + 1}/${files.length}] Upload de ${file.name}...`;

                    const uploadId = await uploadFileInChunks(file);
                    completedUploadIds.push(uploadId);
                }

                progressBar.style.width = '100%';
                statusText.innerText = "Fichiers transférés ! Cliquez sur Enregistrer pour lancer l'extraction en arrière-plan.";
                submitBtn.disabled = false;
                isUploading = false;

            } catch (error) {
                console.error('Upload Error:', error);
                statusText.innerText = "Erreur (upload arrêté) : " + error.message;
                statusText.style.color = "#ff4d4d";
                isUploading = false;
                // Allow them to submit standard data without the folder
                submitBtn.disabled = false;
            }
        });

        form.addEventListener('submit', async function (e) {
            if (isUploading) {
                e.preventDefault();
                alert("Veuillez patienter la fin de l'upload des fichiers.");
                return;
            }

            const files = Array.from(folderInput.files);
            if (files.length === 0) return; // Standard submission if no folder selected

            // If we have completed uploads from the background sync, hijack to send IDs
            if (completedUploadIds.length > 0) {
                e.preventDefault();
                submitBtn.disabled = true;
                statusText.innerText = "Sauvegarde des informations de la série...";
                progressBar.style.width = '50%';
                progressContainer.style.display = 'block';

                try {
                    const formData = new FormData(form);
                    formData.delete('folder_upload');

                    const seriesRes = await safeFetch('', {
                        method: 'POST',
                        body: formData,
                        headers: { 'X-Requested-With': 'XMLHttpRequest' }
                    }, 'Series Save');

                    const seriesData = await seriesRes.json();
                    const series_id = seriesData.series_id;

                    if (!series_id) {
                        throw new Error("Réponse inattendue du serveur.");
                    }

                    statusText.innerText = "Lancement de l'extraction en arrière-plan...";
                    progressBar.style.width = '100%';

                    // Submit all upload IDs for background extraction
                    const processData = new FormData();
                    processData.append('series_id', series_id);
                    processData.append('upload_ids', completedUploadIds.join(','));
                    processData.append('csrfmiddlewaretoken', '{{ csrf_token }}');

                    // Save the IDs to localStorage so the next page knows to poll for progress
                    localStorage.setItem('activeUploads', completedUploadIds.join(','));

                    await safeFetch('{% url "administration:upload_process" %}', {
                        method: 'POST',
                        body: processData
                    }, 'Bulk Process Chapters');

                    statusText.innerText = "Terminé ! L'extraction continue en arrière-plan. Redirection...";
                    setTimeout(() => {
                        window.location.href = "{% url 'administration:series_list' %}";
                    }, 1000);

                } catch (error) {
                    console.error('Save Error:', error);
                    statusText.innerText = "Erreur : " + error.message;
                    statusText.style.color = "#ff4d4d";
                    submitBtn.disabled = false;
                }
            }
        });

        async function uploadFileInChunks(file) {
            const chunkSize = 2 * 1024 * 1024;
            const totalChunks = Math.ceil(file.size / chunkSize);

            // 1. Init
            const rawFilename = file.webkitRelativePath || file.name;
            // Truncate to avoid 255 char DB limit
            const safeFilename = rawFilename.length > 250 ? rawFilename.substring(rawFilename.length - 250) : rawFilename;

            const initData = new FormData();
            initData.append('filename', safeFilename);
            initData.append('total_chunks', totalChunks);
            initData.append('csrfmiddlewaretoken', '{{ csrf_token }}');

            const initRes = await safeFetch('{% url "administration:upload_init" %}', {
                method: 'POST',
                body: initData
            }, 'Upload Init');

            const { upload_id } = await initRes.json();

            // 2. Chunks
            for (let index = 0; index < totalChunks; index++) {
                const start = index * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                const chunk = file.slice(start, end);

                const chunkData = new FormData();
                chunkData.append('upload_id', upload_id);
                chunkData.append('chunk_index', index);
                chunkData.append('chunk', chunk, file.name);
                chunkData.append('csrfmiddlewaretoken', '{{ csrf_token }}');

                await safeFetch('{% url "administration:upload_chunk" %}', {
                    method: 'POST',
                    body: chunkData
                }, `Chunk ${index + 1}/${totalChunks}`);
            }

            // 3. Complete (Assembly)
            const completeData = new FormData();
            completeData.append('upload_id', upload_id);
            completeData.append('csrfmiddlewaretoken', '{{ csrf_token }}');

            await safeFetch('{% url "administration:upload_complete" %}', {
                method: 'POST',
                body: completeData
            }, 'Upload Complete');

            return upload_id;
        }
    });
</script>
{% endblock %}